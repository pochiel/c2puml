%{
#include "t_token.hpp"
#include "parser.hpp"
#include <string.h>
#include <string>
#include <regex>

extern FILE * output_file_ptr;
extern "C" int yylex();
extern void set_comment(const std::string &com) ;
extern void get_comment(std::string &buf);
extern int yyparse();
#ifdef DEBUGOUT
extern int yydebug;
#endif

int g_bracket_cnt = 0;
int g_struct_brachet_cnt = 0;

/* ブロック情報保持スタック */
typedef enum {
	C_BLOCK_TYPE_NONE = 0,
	C_BLOCK_TYPE_FUNCTION,
	C_BLOCK_TYPE_IF,
	C_BLOCK_TYPE_FOR,
	C_BLOCK_TYPE_WHILE,
	C_BLOCK_TYPE_ELSE,
	C_BLOCK_TYPE_WRONG = -10,
} t_blocktype;
#define MAX_OF_BLOCK_STACK	(128)

t_blocktype block_stack[MAX_OF_BLOCK_STACK] = {C_BLOCK_TYPE_NONE};
int block_stack_index = 0;

void push_block_stack(t_blocktype stc)	{
		// printf("*************************** [push] blockstack[%d->%d]=%d\n", block_stack_index, block_stack_index+1, stc);
		block_stack[++	block_stack_index] = stc;
	}
t_blocktype pop_block_stack()	{
	// printf("*************************** [pop] blockstack[%d->%d]=%d\n", block_stack_index, block_stack_index-1, block_stack[block_stack_index]);
	if(block_stack_index==0){ return C_BLOCK_TYPE_WRONG; }
	return block_stack[block_stack_index--];
	}

t_blocktype get_block_stack()	{
	return block_stack[block_stack_index];
}

/* 関数の終端を判別するためのカーリーブレース数カウンタ */
static int g_function_brace_cnt = 0;
/* コメント格納辞書の現在の先頭index */

// _b__buf__ は char *
#define SET_YYLVAL(_b__buf__)	{																\
	std::string temp;																			\
	get_comment(temp);																			\
	yylval.ctype = new t_token();																\
	yylval.ctype->token_str = std::regex_replace(_b__buf__, std::regex("\n|\r\n|\r"), "");		\
	yylval.ctype->comment = temp;																\
}

%}

white       [ |\t|\r|\n]
floating    [0-9]+\.[0-9]+
integer     [0-9]+
symbol      [=+\-\^*/();\n]
letter      [_[:alpha:]][_[:alnum:]]*
other       .
other_cr	[[.]]
all_of_char	[^\{\};]

%x STRING
%x CHARA
%x ST_COMMENT
%x ST_LINE_COMMENT
%x ST_IF_EXPR
%x ST_FOR_EXPR
%x ST_WHILE_EXPR
%x ST_ANY_OTHER
%x ST_SWITCH_EXPR
%x ST_CASE_EXPR
%x ST_RETRN_EXPR
%x ST_GOTO_EXPR
%x ST_TYPEDEF
%x ST_GROBAL_ARRAY_INITIAL
%x ST_FUNCTION
%x ST_FUNC_EQUAL


TYPE            void|char|int|float|double|short|long|signed|unsigned|sizeof
STO_CLASS       extern|static|auto|register
TYPEDEF         typedef|enum|struct|union|class|public|private|protected
CONTROL         if|else|for|while|do|switch|case|default|goto|return|break|continue
TYPE_QUAL       const|volatile
C_KEYWORDS      {TYPE}|{STO_CLASS}|{TYPEDEF}|{TYPE_QUAL}

ALLOC           new|delete
BOOL            bool|false|true
EXCEPTION       try|catch|throw
CLASS           class|public|protected|private|friend|explicit|mutable|inline|virtual|operator|this
CAST            static_cast|reinterpret_cast|const_cast|dynamic_cast
TEMPLATE        template|typename
NAMESPACE       namespace|using
TYPEID          typeid

%%

{white}+

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* 関数宣言を検出して通知する
	*	責務：関数宣言を SET_YYLVAL し、return(FUNCTION)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
	({C_KEYWORDS}|{letter}|{white}|\*)*{white}*{letter}+{white}*\({all_of_char}*\)	{
												if(block_stack_index != 0) {
													REJECT;
												} else {
													BEGIN(ST_FUNCTION);
													SET_YYLVAL(yytext);
													return(FUNCTION);
												}
											}

<ST_FUNCTION>;								{
												BEGIN(INITIAL);
												return(SEMICOLON);
											}

<ST_FUNCTION>=								{
												BEGIN(ST_FUNC_EQUAL);
												return(EQUAL);
											}

<ST_FUNC_EQUAL>\{							{
												return(BRACE);
											}
<ST_FUNC_EQUAL>\}{white}*;					{
												BEGIN(INITIAL);
												return(END_BRACE);
											}
<ST_FUNCTION>\{								{
												g_function_brace_cnt++;
												BEGIN(INITIAL);
												push_block_stack(C_BLOCK_TYPE_FUNCTION);
												return(BRACE);
											}

%{  /*********************************************************************************
	* 構造体宣言など
	*/ %}
({STO_CLASS}{white})*{TYPEDEF}+({TYPEDEF}|{white})*{white}*{letter}*{white}*							{
												if(block_stack_index != 0) {
													/* 構造体宣言は stack 0 でのみ検出
													（もうちょっとうまいやり方ないかなあ・・・） */
													REJECT;
												} else {
													// printf("[Info] struct def.\n");
													BEGIN(ST_TYPEDEF); 
												}
}

<ST_TYPEDEF>\{									{
													g_struct_brachet_cnt++;
												}
<ST_TYPEDEF>\}+{white}*{letter}*{white}*;				{
								g_struct_brachet_cnt--;
								//printf("g_struct_brachet_cnt==%d\n", g_struct_brachet_cnt);
								if(g_struct_brachet_cnt==0){
									BEGIN(INITIAL); 
								}
							}

<ST_TYPEDEF>.				{
								yymore();
							}

#.+[\r\n]

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* if条件を検出して通知する
	*	責務：if条件式を SET_YYLVAL し、BEGIN(INITIAL) し、return(IF)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}

%{  /*********************************************************************************
	* if条件式検出開始
	*/ %}
if{white}*\(				{
								// printf("start if g_bracket_cnt=%d\n", g_bracket_cnt);
								BEGIN(ST_IF_EXPR); 
								g_bracket_cnt++;
								SET_YYLVAL("");
								return(IF);
							}

%{  /*********************************************************************************
	* if条件式検出中の ( 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_IF_EXPR>\(				{
								g_bracket_cnt++;
								//printf("if bracket cnt=%d\n", g_bracket_cnt);
								yymore();
							}

%{  /*********************************************************************************
	* if条件式検出中の ) 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_IF_EXPR>\)				{
								g_bracket_cnt--;
								if(g_bracket_cnt == 0) {
									// if条件式検出完了
									//printf("bracket closed\n");
									//printf("if block\n");

									BEGIN(INITIAL);
									SET_YYLVAL(yytext);
									return(EXPR);
								} else {
									//printf("bracke more g_bracket_cnt=%d", g_bracket_cnt);
									yymore();
								}
							}

%{  /*********************************************************************************
	* if条件式中にコメント
	*/ %}
<ST_IF_EXPR>"/*".*"*/"	{
								// とりあえず無視。
							}

%{  /*********************************************************************************
	*  それ以外の文字。 if条件式を構成する文字であるため、普通に yymore() する。
	*/ %}
<ST_IF_EXPR>.  				{
								//printf("---------if text: %s", yytext);
								yymore();
							}

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* else節検出して通知する、else if はここでは扱わない
	*	責務：return(else)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
%{  /*********************************************************************************
	*  else の検出
	*/ %}
else						{
								// printf("start else block\n");
								SET_YYLVAL("");
								return(ELSE);
							}


%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* for 検出して通知する
	*	責務：for条件式を SET_YYLVAL し、BEGIN(INITIAL) し、return(FOR)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
%{  /*********************************************************************************
	* for条件式検出開始
	*/ %}
for{white}*\(				{
								// printf("start for g_bracket_cnt=%d\n", g_bracket_cnt);
								BEGIN(ST_FOR_EXPR);
								g_bracket_cnt++;
								SET_YYLVAL("");
								return(FOR);
							}

%{  /*********************************************************************************
	* for条件式検出中の ) 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_FOR_EXPR>\)				{
								g_bracket_cnt--;
								if(g_bracket_cnt == 0) {
									// for条件式検出完了
									// printf("bracket closed\n");
									// printf("for block\n");
									BEGIN(INITIAL);

									SET_YYLVAL(yytext);
									return(EXPR);
								} else {
									yymore();
								}
							}

%{  /*********************************************************************************
	* for条件式検出中の ( 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_FOR_EXPR>\(				{
								g_bracket_cnt++;
								// printf("for bracket cnt=%d", g_bracket_cnt);
								yymore();
							}

%{  /*********************************************************************************
	* for条件式中にコメント
	*/ %}
<ST_FOR_EXPR>"/*".*"*/"		{
								// とりあえず無視。
							}

%{  /*********************************************************************************
	*  それ以外の文字。 for条件式を構成する文字であるため、普通に yymore() する。
	*/ %}
<ST_FOR_EXPR>.  			{	yymore(); }

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* for 検出して通知する
	*	責務：for条件式を SET_YYLVAL し、BEGIN(INITIAL) し、return(FOR)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
%{  /*********************************************************************************
	* while条件式検出開始
	*/ %}
while{white}*\(				{
								// printf("start for g_bracket_cnt=%d\n", g_bracket_cnt);
								BEGIN(ST_WHILE_EXPR);
								g_bracket_cnt++;
								SET_YYLVAL("");
								return(WHILE);
							}
%{  /*********************************************************************************
	* while 条件式検出中の ( 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_WHILE_EXPR>\(			{
								g_bracket_cnt++;
								// printf("while bracket cnt=%d", g_bracket_cnt);
								yymore();
							}
%{  /*********************************************************************************
	* while 条件式検出中の ) 検出.  g_bracket_cnt == 0 ならば、while条件式検出完了
	*/ %}
<ST_WHILE_EXPR>\)   		{
								g_bracket_cnt--;
								if(g_bracket_cnt == 0) {
									BEGIN(INITIAL);
									yytext[yyleng] = 0;
									SET_YYLVAL(yytext);
									return(EXPR);
								} else {
									yymore();
								}
							}

%{  /*********************************************************************************
	* while 条件式中にコメント
	*/ %}
<ST_WHILE_EXPR>"/*".*"*/"		{
								// とりあえず無視。
							}


%{  /*********************************************************************************
	*  それ以外の文字。 while条件式を構成する文字であるため、普通に yymore() する。
	*/ %}
<ST_WHILE_EXPR>.  			{	yymore(); }

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* コメントの検出処理
	*	責務：コメント内容を 一次バッファに保存し、BEGIN(INITIAL) する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
"/*"            		{	BEGIN(ST_COMMENT); yymore();	}
<ST_COMMENT>"*/"   		{	// printf("Comment(s):        (%s) len=%d\n", yytext, yyleng);
							BEGIN(INITIAL);
							set_comment(std::string(yytext));
						}
<ST_COMMENT>"*"    		{	yymore(); }
<ST_COMMENT>[^*]+  		{	yymore(); }

"//".*(\r|\n) 			{	// printf(f"Comment(s):        (%s) len=%d\n", yytext, yyleng); 
							set_comment(std::string(yytext));
						}


%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* switch case処理
	*	責務：switch条件式を SET_YYLVAL し、BEGIN(INITIAL) し、return(SWTICH)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
%{  /*********************************************************************************
	*  switch 条件式を検出開始する。
	*/ %}
switch{white}*			{
							BEGIN(ST_SWITCH_EXPR); 
							SET_YYLVAL("");
							return(SWITCH);
						}

%{  /*********************************************************************************
	* switch条件式検出中の ( 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_SWITCH_EXPR>\(			{
								g_bracket_cnt++;
								yymore();
							}

%{  /*********************************************************************************
	* expr条件式検出中の ) 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_SWITCH_EXPR>\)				{
								g_bracket_cnt--;
								if(g_bracket_cnt == 0) {
									// switch条件式検出完了
									BEGIN(INITIAL);
									SET_YYLVAL(yytext);
									return(EXPR);
								} else {
									yymore();
								}
							}

%{  /*********************************************************************************
	*  それ以外の文字。 switch条件式を構成する文字であるため、普通に yymore() する。
	*/ %}
<ST_SWITCH_EXPR>.  			{
								yymore();
							}

%{  /*********************************************************************************
	*  caseを検出する。
	*   case 条件式をSET_YYLVAL し、BEGIN(INITIAL) し、return(CASE)する 
	*/ %}
%{  /*********************************************************************************
	*  case 条件式を検出開始する。
	*/ %}
case{white}+			{
							BEGIN(ST_CASE_EXPR); 
							return(CASE);
						}

%{  /*********************************************************************************
	* case expr条件式検出中の : 検出. 完結したとみなす。
	*/ %}
<ST_CASE_EXPR>:			{
								// case条件式検出完了
								BEGIN(INITIAL);
								SET_YYLVAL(yytext);
								return(EXPR);
							}


%{  /*********************************************************************************
	*  それ以外の文字。 switch条件式を構成する文字であるため、普通に yymore() する。
	*/ %}
<ST_CASE_EXPR>.  			{
								yymore();
							}

%{  /*********************************************************************************
	*  default句を検出する。
	*   return(ELSE)する 
	*/ %}

default{white}*:		{
							// printf("Start switch case in default block\n");
							SET_YYLVAL("");
							return(DEFAULT);
						}

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* カギカッコ {} 処理 blockの終端処理
	*	責務：現在の block_stack からpopし、閉じた block の種類に応じて適切な終端処理を行う
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
\{						{
							g_function_brace_cnt++;
							//printf("start brace g_function_brace_cnt=%d\n", g_function_brace_cnt);
							SET_YYLVAL("");
							return(BRACE);
						}

\}   					{
							g_function_brace_cnt--;
							//printf("end brace g_function_brace_cnt=%d\n", g_function_brace_cnt);
							if(g_function_brace_cnt==0){
								pop_block_stack();		// 関数終了
							}
							SET_YYLVAL("");
							return(END_BRACE);
						}

<ST_GROBAL_ARRAY_INITIAL>\}   {
							BEGIN(INITIAL);
							REJECT;
						}

%{  /*********************************************************************************
	*  ; だけの入力を無視する。 do { } while(expr); の末尾の ; を無視する。
	*/ %}
;					{ }


%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* Any other 系処理。
	*	責務：1行まるごと push_synbol_string し、BEGIN(INITIAL) し、return(IF)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
%{  /*********************************************************************************
	*  ST_ANY_OTHER状態を開始する。 １行まるごとを yytext に取り込むために yymore する。
	*/ %}
.					{
						BEGIN(ST_ANY_OTHER);
						yymore();
					}

%{  /*********************************************************************************
	*  なんか入ってきたら取り込む。コンマを終端記号として１行を終える。
	*/ %}
<ST_ANY_OTHER>.*;	{
						BEGIN(INITIAL); 
						SET_YYLVAL(yytext);
						return(ANY_OTHER);
					}

%{  /*********************************************************************************
	*  それ以外の何かが入ってきた。
	*/ %}
<ST_ANY_OTHER>. {	yymore(); }

%{  /*********************************************************************************
	*  グローバルスコープで関数宣言初期化中
	*/ %}
<ST_GROBAL_ARRAY_INITIAL>.   { }

%{  /*********************************************************************************
	*  do の検出
	*/ %}
do{white}+					{ 	return(DO); }

%{  /*********************************************************************************
	*  break の検出
	*/ %}
break{white}*;				{ 	return(BREAK); }

%{  /*********************************************************************************
	*  continue  の検出
	*/ %}
continue{white}*;			{ 	return(CONTINUE); }

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* return 検出して通知する
	*	責務：return条件式を SET_YYLVAL し、BEGIN(INITIAL) し、return(RETRN)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}

%{  /*********************************************************************************
	* return条件式検出開始
	*/ %}
return{white}+				{
								BEGIN(ST_RETRN_EXPR);
								return(RETRN);
							}
%{  /*********************************************************************************
	* return 条件式検出中の ; 検出.  return条件式検出完了
	*/ %}
<ST_RETRN_EXPR>\;   		{
								BEGIN(INITIAL);
								SET_YYLVAL(yytext);
								return(EXPR);
							}

%{  /*********************************************************************************
	*  それ以外の何かが入ってきた。
	*/ %}
<ST_RETRN_EXPR>. {	yymore(); }

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* return 検出して通知する
	*	責務：return条件式を SET_YYLVAL し、BEGIN(INITIAL) し、return(RETRN)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}

%{  /*********************************************************************************
	* goto条件式検出開始
	*/ %}
goto{white}+				{
								BEGIN(ST_GOTO_EXPR);
								return(GOTO);
							}
%{  /*********************************************************************************
	* goto 条件式検出中の ; 検出.  goto条件式検出完了
	*/ %}
<ST_GOTO_EXPR>\;   			{
								BEGIN(INITIAL);
								SET_YYLVAL(yytext);
								return(EXPR);
							}

%{  /*********************************************************************************
	*  それ以外の何かが入ってきた。
	*/ %}
<ST_GOTO_EXPR>. {	yymore(); }

%{  /*********************************************************************************
	* gotoラベルの検出.
	*/ %}
{letter}+:					{
								SET_YYLVAL(yytext);
								return(LABEL);
							}
%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* ファイル終端処理。ここが終わり。 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
<<EOF>>			{ // printf("end of file\n");
					return(0); }

%%

#define C_OUTPUT_FILE_MAX    (256)

void yyerror(char const*){
}
/*****************************************************************************************************************************************************************
	エントリーポイント
******************************************************************************************************************************************************************/
int main(int argc, char *argv[])
{
    FILE * fptr_r = NULL;
    FILE * fptr_w = NULL;
    int i;
    char opt;
    char output_filne_name[C_OUTPUT_FILE_MAX] = {0};
    char input_filne_name[C_OUTPUT_FILE_MAX] = {0};

#ifdef DEBUGOUT
	yydebug = YYDEBUG;
#endif

    /* default name. */
    strncpy(output_filne_name, "out.puml", C_OUTPUT_FILE_MAX);

    for(i = 1; i < argc; ++i){
        if(*argv[i] == '-'){
            opt = *(argv[i]+1);
            switch(opt){
                case 'o':
                    strncpy(output_filne_name, argv[i+1], C_OUTPUT_FILE_MAX);
                    break;
                default:
                    printf("Undefined Option.\n");
                    break;
            }
            i++;
        } else {
            sprintf(input_filne_name, "%s", argv[i]);
        }
    }
    /* input filename error check */
    if(strlen(input_filne_name) == 0) {
        printf("input filename error.\n");
        exit(1);
    }
    /* Read file pointer */
    if ((fptr_r = fopen(input_filne_name, "r"))==NULL) {
        printf("file open failed.\n");
        exit(1);
    }
    
    /* write file pointer */
    if ((fptr_w = fopen(output_filne_name, "w"))==NULL) {
        printf("output file open failed.\n");
        exit(1);
    }

    /* 構文解析関数 yyparse */
    yyin = fptr_r;
    output_file_ptr = fptr_w;
    if( yyparse() != 0 ){
        printf("parse error.\n");
    }
    fclose(fptr_r);
    fclose(fptr_w);
    return 0;
}
