%{
#include "parser.hpp"
#include <string.h>
#include <string>

extern FILE * output_file_ptr;
extern "C" int yylex();
extern void set_comment(const std::string &com) ;
extern void get_comment(std::string &buf);

int g_bracket_cnt = 0;

enum {
	C_UNRELATED_ELSE = 0,
	C_WITH_ELSE_SINGLE,
	C_WITH_ELSE_BLOCK,
};

enum {
	C_UNRELATED_WHILE = 0,
	C_WITH_BLOCK,
	C_WITHOUT_BLOCK,
};

// if節がどのように始まったかを記憶しておくフラグ、現在のブロックが { ありか、なしかを示す。
// { の無いシングル if の場合、１行後にすぐ endif もしくは else しないといけない。
int is_else_in_if = C_UNRELATED_ELSE;

// for節がどのように始まったかを記憶しておくフラグ、現在のブロックが { ありか、なしかを示す。
// { の無いシングル for の場合、１行後にすぐ endforしなければならない。
int is_block_of_for = C_UNRELATED_WHILE;

/* 指定した任意の1文字を削除する */
void remove_char(char target, char converted_char, char* in_str, int in_length){
	for(int i=0;i<in_length;i++){
		if( in_str[i] == target ){
			in_str[i] = converted_char;
		}
	}
}

/* 改行を削除する */
void remove_line_feed(const char* in_str, int in_length, char* out_str, int *out_length){
	sprintf(out_str, "%s", in_str);
	remove_char('\n', ' ', out_str, in_length);
	remove_char('\r', ' ', out_str, in_length);
}

/* ブロック情報保持スタック */
typedef enum {
	C_BLOCK_TYPE_NONE = 0,
	C_BLOCK_TYPE_FUNCTION,
	C_BLOCK_TYPE_IF,
	C_BLOCK_TYPE_FOR,
	C_BLOCK_TYPE_WHILE,
	C_BLOCK_TYPE_ELSE,
	C_BLOCK_TYPE_WRONG = -10,
} t_blocktype;
#define MAX_OF_BLOCK_STACK	(128)



t_blocktype block_stack[MAX_OF_BLOCK_STACK] = {C_BLOCK_TYPE_NONE};
int block_stack_index = 0;

void push_block_stack(t_blocktype stc)	{
		// printf("*************************** [push] blockstack[%d->%d]=%d\n", block_stack_index, block_stack_index+1, stc);
		block_stack[++	block_stack_index] = stc;
	}
t_blocktype pop_block_stack()	{
	// printf("*************************** [pop] blockstack[%d->%d]=%d\n", block_stack_index, block_stack_index-1, block_stack[block_stack_index]);
	if(block_stack_index==0){ return C_BLOCK_TYPE_WRONG; }
	return block_stack[block_stack_index--];
	}

t_blocktype get_block_stack()	{
	return block_stack[block_stack_index];
}

/* 関数の終端を判別するためのカーリーブレース数カウンタ */
static int g_function_brace_cnt = 0;
/* コメント格納辞書の現在の先頭index */

// _b__buf__ は char *
#define SET_YYLVAL(_b__buf__)	{							\
	std::string temp;										\
	get_comment(temp);										\
	yylval.ctype = new t_token();							\
	yylval.ctype->token_str = std::string(_b__buf__);		\
	yylval.ctype->comment = temp;							\
}

%}

white       [ |\t|\r|\n]
floating    [0-9]+\.[0-9]+
integer     [0-9]+
symbol      [=+\-\^*/();\n]
letter      [_[:alpha:]][_[:alnum:]]*
other       .
other_cr	[[.]]

%x STRING
%x CHARA
%x ST_COMMENT
%x ST_LINE_COMMENT
%x ST_IF_EXPR
%x ST_FOR_EXPR
%x ST_WHILE_EXPR
%x ST_ANY_OTHER
%x ST_SWITCH_EXPR
%x ST_CASE_EXPR
%x ST_RETRN_EXPR
%x ST_GOTO_EXPR


TYPE            void|char|int|float|double|short|long|signed|unsigned|sizeof
STO_CLASS       extern|static|auto|register
TYPEDEF         typedef|enum|struct|union
CONTROL         if|else|for|while|do|switch|case|default|goto|return|break|continue
TYPE_QUAL       const|volatile
C_KEYWORDS      {TYPE}|{STO_CLASS}|{TYPEDEF}|{TYPE_QUAL}

ALLOC           new|delete
BOOL            bool|false|true
EXCEPTION       try|catch|throw
CLASS           class|public|protected|private|friend|explicit|mutable|inline|virtual|operator|this
CAST            static_cast|reinterpret_cast|const_cast|dynamic_cast
TEMPLATE        template|typename
NAMESPACE       namespace|using
TYPEID          typeid

%%

{white}+

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* 関数宣言を検出して通知する
	*	責務：関数宣言を SET_YYLVAL し、return(FUNCTION)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
({C_KEYWORDS}|{letter}|{white}|\*)*{white}*{letter}+{white}*\([^\(\)]*\)	{
												if(block_stack_index != 0) {
													/* 関数宣言は stack 0 でのみ検出
													（もうちょっとうまいやり方ないかなあ・・・） */
													// printf("[Info] function def rejected.\n");
													REJECT;
												} else {
													SET_YYLVAL(yytext);
													push_block_stack(C_BLOCK_TYPE_FUNCTION);
													return(FUNCTION);
												}
											}

%{  /*********************************************************************************
	* プロトタイプ宣言
	*/ %}
({C_KEYWORDS}|{letter}|{white}|\*)*{white}*{letter}+{white}*\([^\(\)]*\){white}*;	{
												if(block_stack_index != 0) {
													/* 関数宣言は stack 0 でのみ検出
													（もうちょっとうまいやり方ないかなあ・・・） */
													// printf("[Info] prototype def rejected.\n");
													REJECT;
												} else {
													SET_YYLVAL(yytext);
													return(PROTOTYPE);
												}
											}

#.+[\r\n]

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* if条件を検出して通知する
	*	責務：if条件式を SET_YYLVAL し、BEGIN(INITIAL) し、return(IF)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}

%{  /*********************************************************************************
	* if条件式検出開始
	*/ %}
if{white}*\(				{
								// printf("start if g_bracket_cnt=%d\n", g_bracket_cnt);
								BEGIN(ST_IF_EXPR); 
								g_bracket_cnt++;
								SET_YYLVAL("");
								return(IF);
							}

%{  /*********************************************************************************
	* if条件式検出中の ( 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_IF_EXPR>\(				{
								g_bracket_cnt++;
								printf("if bracket cnt=%d\n", g_bracket_cnt);
								yymore();
							}

%{  /*********************************************************************************
	* if条件式検出中の ) 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_IF_EXPR>\)				{
								g_bracket_cnt--;
								if(g_bracket_cnt == 0) {
									// if条件式検出完了
									printf("bracket closed\n");
									printf("if block\n");

									BEGIN(INITIAL);
									SET_YYLVAL(yytext);
									return(EXPR);
								} else {
									printf("bracke more g_bracket_cnt=%d", g_bracket_cnt);
									yymore();
								}
							}

%{  /*********************************************************************************
	* if条件式中にコメント
	*/ %}
<ST_IF_EXPR>"/*".*"*/"	{
								// とりあえず無視。
							}

%{  /*********************************************************************************
	*  それ以外の文字。 if条件式を構成する文字であるため、普通に yymore() する。
	*/ %}
<ST_IF_EXPR>.  				{
								printf("---------if text: %s", yytext);
								yymore();
							}

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* else節検出して通知する、else if はここでは扱わない
	*	責務：return(else)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
%{  /*********************************************************************************
	*  else の検出
	*/ %}
else						{
								// printf("start else block\n");
								SET_YYLVAL("");
								return(ELSE);
							}


%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* for 検出して通知する
	*	責務：for条件式を SET_YYLVAL し、BEGIN(INITIAL) し、return(FOR)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
%{  /*********************************************************************************
	* for条件式検出開始
	*/ %}
for{white}*\(				{
								// printf("start for g_bracket_cnt=%d\n", g_bracket_cnt);
								BEGIN(ST_FOR_EXPR);
								g_bracket_cnt++;
								SET_YYLVAL("");
								return(FOR);
							}

%{  /*********************************************************************************
	* for条件式検出中の ) 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_FOR_EXPR>\)				{
								g_bracket_cnt--;
								if(g_bracket_cnt == 0) {
									// for条件式検出完了
									// printf("bracket closed\n");
									// printf("for block\n");
									BEGIN(INITIAL);

									SET_YYLVAL(yytext);
									return(EXPR);
								} else {
									yymore();
								}
							}

%{  /*********************************************************************************
	* for条件式検出中の ( 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_FOR_EXPR>\(				{
								g_bracket_cnt++;
								// printf("for bracket cnt=%d", g_bracket_cnt);
								yymore();
							}

%{  /*********************************************************************************
	* for条件式中にコメント
	*/ %}
<ST_FOR_EXPR>"/*".*"*/"		{
								// とりあえず無視。
							}

%{  /*********************************************************************************
	*  それ以外の文字。 for条件式を構成する文字であるため、普通に yymore() する。
	*/ %}
<ST_FOR_EXPR>.  			{	yymore(); }

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* for 検出して通知する
	*	責務：for条件式を SET_YYLVAL し、BEGIN(INITIAL) し、return(FOR)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
%{  /*********************************************************************************
	* while条件式検出開始
	*/ %}
while{white}*\(				{
								// printf("start for g_bracket_cnt=%d\n", g_bracket_cnt);
								BEGIN(ST_WHILE_EXPR);
								g_bracket_cnt++;
								SET_YYLVAL("");
								return(WHILE);
							}
%{  /*********************************************************************************
	* while 条件式検出中の ( 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_WHILE_EXPR>\(			{
								g_bracket_cnt++;
								// printf("while bracket cnt=%d", g_bracket_cnt);
								yymore();
							}
%{  /*********************************************************************************
	* while 条件式検出中の ) 検出.  g_bracket_cnt == 0 ならば、while条件式検出完了
	*/ %}
<ST_WHILE_EXPR>\)   		{
								g_bracket_cnt--;
								if(g_bracket_cnt == 0) {
									BEGIN(INITIAL);
									SET_YYLVAL(yytext);
									return(EXPR);
								} else {
									yymore();
								}
							}

%{  /*********************************************************************************
	* while 条件式中にコメント
	*/ %}
<ST_WHILE_EXPR>"/*".*"*/"		{
								// とりあえず無視。
							}


%{  /*********************************************************************************
	*  それ以外の文字。 while条件式を構成する文字であるため、普通に yymore() する。
	*/ %}
<ST_WHILE_EXPR>.  			{	yymore(); }

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* コメントの検出処理
	*	責務：コメント内容を 一次バッファに保存し、BEGIN(INITIAL) する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
"/*"            		{	BEGIN(ST_COMMENT); yymore();	}
<ST_COMMENT>"*/"   		{	// printf("Comment(s):        (%s) len=%d\n", yytext, yyleng);
							BEGIN(INITIAL);
							set_comment(std::string(yytext));
						}
<ST_COMMENT>"*"    		{	yymore(); }
<ST_COMMENT>[^*]+  		{	yymore(); }

"//".*(\r|\n) 			{	// printf(f"Comment(s):        (%s) len=%d\n", yytext, yyleng); 
							set_comment(std::string(yytext));
						}


%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* switch case処理
	*	責務：switch条件式を SET_YYLVAL し、BEGIN(INITIAL) し、return(SWTICH)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
%{  /*********************************************************************************
	*  switch 条件式を検出開始する。
	*/ %}
switch{white}*			{
							BEGIN(ST_SWITCH_EXPR); 
							SET_YYLVAL("");
							return(SWITCH);
						}

%{  /*********************************************************************************
	* switch条件式検出中の ( 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_SWITCH_EXPR>\(			{
								g_bracket_cnt++;
								yymore();
							}

%{  /*********************************************************************************
	* expr条件式検出中の ) 検出. g_bracke_cntが0になるまで式が完結したとはみなさない
	*/ %}
<ST_SWITCH_EXPR>\)				{
								g_bracket_cnt--;
								if(g_bracket_cnt == 0) {
									// switch条件式検出完了
									BEGIN(INITIAL);
									SET_YYLVAL(yytext);
									return(EXPR);
								} else {
									yymore();
								}
							}

%{  /*********************************************************************************
	*  それ以外の文字。 switch条件式を構成する文字であるため、普通に yymore() する。
	*/ %}
<ST_SWITCH_EXPR>.  			{
								yymore();
							}

%{  /*********************************************************************************
	*  caseを検出する。
	*   case 条件式をSET_YYLVAL し、BEGIN(INITIAL) し、return(CASE)する 
	*/ %}
%{  /*********************************************************************************
	*  case 条件式を検出開始する。
	*/ %}
case{white}+			{
							BEGIN(ST_CASE_EXPR); 
							return(CASE);
						}

%{  /*********************************************************************************
	* case expr条件式検出中の : 検出. 完結したとみなす。
	*/ %}
<ST_CASE_EXPR>:			{
								// case条件式検出完了
								BEGIN(INITIAL);
								SET_YYLVAL(yytext);
								return(EXPR);
							}


%{  /*********************************************************************************
	*  それ以外の文字。 switch条件式を構成する文字であるため、普通に yymore() する。
	*/ %}
<ST_CASE_EXPR>.  			{
								yymore();
							}

%{  /*********************************************************************************
	*  default句を検出する。
	*   return(ELSE)する 
	*/ %}

default{white}*:		{
							// printf("Start switch case in default block\n");
							SET_YYLVAL("");
							return(DEFAULT);
						}

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* 二重カッコ {} 処理 blockの終端処理
	*	責務：現在の block_stack からpopし、閉じた block の種類に応じて適切な終端処理を行う
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
\{						{
							g_function_brace_cnt++;
							//printf("start brace g_function_brace_cnt=%d\n", g_function_brace_cnt);
							SET_YYLVAL("");
							return(BRACE);
						}

\}   					{
							g_function_brace_cnt--;
							//printf("end brace g_function_brace_cnt=%d\n", g_function_brace_cnt);
							if(g_function_brace_cnt==0){
								pop_block_stack();		// 関数終了
							}
							SET_YYLVAL("");
							return(END_BRACE);
						}

%{  /*********************************************************************************
	*  ; だけの入力を無視する。 do { } while(expr); の末尾の ; を無視する。
	*/ %}
;					{ }


%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* Any other 系処理。
	*	責務：1行まるごと push_synbol_string し、BEGIN(INITIAL) し、return(IF)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
%{  /*********************************************************************************
	*  ST_ANY_OTHER状態を開始する。 １行まるごとを yytext に取り込むために yymore する。
	*/ %}
.					{
						BEGIN(ST_ANY_OTHER);
						yymore();
					}

%{  /*********************************************************************************
	*  なんか入ってきたら取り込む。コンマを終端記号として１行を終える。
	*/ %}
<ST_ANY_OTHER>.*;	{
						BEGIN(INITIAL); 
						SET_YYLVAL(yytext);
						return(ANY_OTHER);
					}

%{  /*********************************************************************************
	*  それ以外の何かが入ってきた。
	*/ %}
<ST_ANY_OTHER>. {	yymore(); }

%{  /*********************************************************************************
	*  do の検出
	*/ %}
do{white}+					{ 	return(DO); }

%{  /*********************************************************************************
	*  break の検出
	*/ %}
break{white}*;				{ 	return(BREAK); }

%{  /*********************************************************************************
	*  continue  の検出
	*/ %}
continue{white}*;			{ 	return(CONTINUE); }

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* return 検出して通知する
	*	責務：return条件式を SET_YYLVAL し、BEGIN(INITIAL) し、return(RETRN)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}

%{  /*********************************************************************************
	* return条件式検出開始
	*/ %}
return{white}+				{
								BEGIN(ST_RETRN_EXPR);
								return(RETRN);
							}
%{  /*********************************************************************************
	* return 条件式検出中の ; 検出.  return条件式検出完了
	*/ %}
<ST_RETRN_EXPR>\;   		{
								BEGIN(INITIAL);
								SET_YYLVAL(yytext);
								return(EXPR);
							}

%{  /*********************************************************************************
	*  それ以外の何かが入ってきた。
	*/ %}
<ST_RETRN_EXPR>. {	yymore(); }

%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* return 検出して通知する
	*	責務：return条件式を SET_YYLVAL し、BEGIN(INITIAL) し、return(RETRN)する 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}

%{  /*********************************************************************************
	* goto条件式検出開始
	*/ %}
goto{white}+				{
								BEGIN(ST_GOTO_EXPR);
								return(GOTO);
							}
%{  /*********************************************************************************
	* goto 条件式検出中の ; 検出.  goto条件式検出完了
	*/ %}
<ST_GOTO_EXPR>\;   			{
								BEGIN(INITIAL);
								SET_YYLVAL(yytext);
								return(EXPR);
							}

%{  /*********************************************************************************
	*  それ以外の何かが入ってきた。
	*/ %}
<ST_GOTO_EXPR>. {	yymore(); }


%{  /*****************************************************************************************************************************************************************
	******************************************************************************************************************************************************************
	* ファイル終端処理。ここが終わり。 
	******************************************************************************************************************************************************************
	******************************************************************************************************************************************************************/ %}
<<EOF>>			{ // printf("end of file\n");
					return(0); }

%%

#define C_OUTPUT_FILE_MAX    (256)

void yyerror(char const*){
}
/*****************************************************************************************************************************************************************
	エントリーポイント
******************************************************************************************************************************************************************/
int main(int argc, char *argv[])
{
    FILE * fptr_r = NULL;
    FILE * fptr_w = NULL;
    int i;
    char opt;
    char output_filne_name[C_OUTPUT_FILE_MAX] = {0};
    char input_filne_name[C_OUTPUT_FILE_MAX] = {0};

	yydebug = 1;

    /* default name. */
    strncpy(output_filne_name, "out.puml", C_OUTPUT_FILE_MAX);

    for(i = 1; i < argc; ++i){
        if(*argv[i] == '-'){
            opt = *(argv[i]+1);
            switch(opt){
                case 'o':
                    strncpy(output_filne_name, argv[i+1], C_OUTPUT_FILE_MAX);
                    break;
                default:
                    printf("Undefined Option.\n");
                    break;
            }
            i++;
        } else {
            sprintf(input_filne_name, "%s", argv[i]);
        }
    }
    /* input filename error check */
    if(strlen(input_filne_name) == 0) {
        printf("input filename error.\n");
        exit(1);
    }
    /* Read file pointer */
    if ((fptr_r = fopen(input_filne_name, "r"))==NULL) {
        printf("file open failed.\n");
        exit(1);
    }
    
    /* write file pointer */
    if ((fptr_w = fopen(output_filne_name, "w"))==NULL) {
        printf("output file open failed.\n");
        exit(1);
    }

    /* 構文解析関数 yyparse */
    yyin = fptr_r;
    output_file_ptr = fptr_w;
    if( yyparse() != 0 ){
        printf("parse error.\n");
    }
    fclose(fptr_r);
    fclose(fptr_w);
    return 0;
}
